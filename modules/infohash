#!/bin/bash
# get CPU params and Core Count

## check to see if infohash is run in cli or irc.
## The kernel does not support throttling of individual core frequencies(GHz).
## It can use each core as needed, but the frequencies(GHz) of each will match.
## Don't confuse usage(%) with frequency(GHz).
## Multi-core cpu's in flavors of 4,6,and 8 need only one line to show the core type and this will reduce the spam output
## F is field separator, i.e ':', $NF (here) means the last field in the line
get_cpu_model()
{
    if [[ -e /proc/cpuinfo ]]; then
        gawk -F': ' 'BEGIN {IGNORECASE=1} /^model name/ { cpu_model = $2 } END { print cpu_model }' /proc/cpuinfo | uniq
    fi
}

get_cpu_freq()
{
    if [[ -e /proc/cpuinfo ]]; then
        gawk -F': ' 'BEGIN {IGNORECASE=1} /^cpu MHz/ { cpu_freq = $2 } END { print cpu_freq }' /proc/cpuinfo | uniq
    fi
}

get_cpu_cache_size()
{
    if [[ -e /proc/cpuinfo ]]; then
        gawk -F': ' 'BEGIN {IGNORECASE=1} /^cache size/ { cpu_cache = $2 } END { print cpu_cache }' /proc/cpuinfo | uniq
    fi
}

get_cpu_bogomips()
{
    if [[ -e /proc/cpuinfo ]]; then
        gawk -F': ' 'BEGIN {IGNORECASE=1} /^bogomips/ { cpu_bogomips = $2 } END { print cpu_bogomips }' /proc/cpuinfo | uniq
    fi
}

get_cpu_core_count()
{
    core_count=$(grep -c "cpu cores" /proc/cpuinfo| cut -d':' -f2) # count the number of processors given
    echo $core_count
}

give_cpu_core_alpha_count()
{
## Because of the upcoming release of cpus with core counts over 6, a count of cores is given after Deca (10)
    if [[ $(get_cpu_core_count) -lt 2 ]]; then
      cpu_core_count=1
    else
        cpu_core_count=$(get_cpu_core_count)
    fi

    case $cpu_core_count in # match the numberic value to an alpha value
        1) cpu_alpha_count="Single ";;
        2) cpu_alpha_count="Dual ";;
        3) cpu_alpha_count="Triple ";;
        4) cpu_alpha_count="Quad ";;
        5) cpu_alpha_count="Penta ";;
        6) cpu_alpha_count="Hexa ";;
        7) cpu_alpha_count="Hepta ";;
        8) cpu_alpha_count="Octa ";;
        9) cpu_alpha_count="Ennea ";;
       10) cpu_alpha_count="Deca ";;
        *) cpu_alpha_count="Multi ";;
    esac

    core_count="$cpu_alpha_count Core"
    echo $core_count
}

cpu_64_32_bit_check()
{
## look in /proc/cpuinfo "flags:" section for the flag "lm" which is the flag for 64bit processor
    bit_32_64=$(grep "flags" /proc/cpuinfo | grep -ic ' lm ')
    if [ $bit_32_64 -gt 0 ]; then
        bit_32_64="64 bit"
    else
        bit_32_64="32 bit"
    fi
    echo $bit_32_64
}

remove_erroneous_chars()
{
## this removes newline and pipes
## RS is input record separator
## gsub is substitute;
    gawk 'BEGIN { RS="" } { gsub(/\n$/,"");         ## (newline; end of string) with (nothing)
                            gsub(/\n/," ");         ## (newline) with (space)
                            gsub(/^ *| *$/, "");    ## (pipe char) with (nothing)
                            gsub(/  +/, " ");       ## ( +) with (space)
                            gsub(/ [ ]+/, " ");     ## ([ ]+) with (space)
                            gsub(/^ +| +$/, "");    ## (pipe char) with (nothing)
                            printf $0 }' "$1"       ## prints (returns) cleaned input
}

get_ide_hdd_params() ## do not directly access this function, use the function verify_ide_drives_exist !!
{
    if [ -e /proc/ide/ide0 ];then  #check for the presense of ide folder found on most older non-sata systems (libata for info)
        for I in /proc/ide/ide*/hd*; do
            if [[ -e $I/media ]]; then
                if [[ $(remove_erroneous_chars $I/media) = disk ]]; then
                    if [[ -e $I/capacity ]]; then ## /capacity is not in all systems
                        ((hdd_drive_capacity+=$(remove_erroneous_chars $I/capacity)/1000000))
                    else
                        hdd_drive_capacity=0
                    fi
                fi
            ide_drives="${ide_drives}${ide_drives+,}$(remove_erroneous_chars $I/model)"
            fi
        done
        echo "IDE: "$ide_drives, " Capacity: "$hdd_drive_capacity"""MB"
    fi
}

verify_ide_drives_exist()
{
## this will varify the existance of IDE (without libata) drives before giving data
if [[ -n $(get_ide_hdd_params) ]]; then
    get_ide_hdd_params
fi
}

get_drive_size()
{
## searches /proc/partitions for any mounted drive, i.e. hda, sda, hdb, sdb,etc
## does not look for individual partitions
## returns value in GigaBytes without any decimal
## Multiply by 1.024 to give "marketing" size, i.e. size on box vs formated size
if [[ -e /proc/partitions ]]; then
   gawk -F' ' '
      $4 ~ /^[hs]d[a-z]$/ { drive_size+=$3 }
      ## $4 is the drive name/type (i.e. hda, sda)
   END {
      printf "%1.0f\n", (drive_size/1000000)
      ## "%1.0f" removes decimals; then divide by 1,000,000 to get GB and
   }
   ' /proc/partitions
fi
}

get_drives_used_amount()
{
## this will get the listed "Used" amounts from 'df' then add the ammounts for all drives
## given in KB
   if [[ $(get_drive_size) -gt 0 ]]; then
      df | gawk ' { if (/^\/dev\/([hs]d[a-z][0-9]+)/) { c += $3 } }
         END { print c }'
   fi
}

percent_drive_usage()
{
## Given as % used; see functions get_drive_size() and get_drives_used_amount() for more infomation
if [[ $(get_drive_size) -gt 0 ]]; then
    echo "$(($(get_drives_used_amount)/$(get_drive_size)/10000))"
fi
}

get_libata_hdd_params()
{
    if [[ -e /proc/scsi/sg/device_strs ]]; then
      gawk -F'\t' ' BEGIN { IGNORECASE=1 }
      $1 ~ /^ata|scsi/    { print $2 }   ## prints out hdd device if field one is ATA type (sata compatibility mode) or prints out scsi device
      ' /proc/scsi/sg/device_strs
    fi
}

get_libata_usb_params()
{
    if [[ -e /proc/scsi/sg/device_strs ]]; then
      gawk -F'\t' ' BEGIN { IGNORECASE=1 }
      $1 !~ /^ata|scsi/    { print $1" "$2 }   ## prints out usb and cd/dvd r/w
      ' /proc/scsi/sg/device_strs
    fi
}

remove_erroneous_chars()
{
## this removes newline and pipes
## RS is input record separator
## gsub is substitute;
    gawk 'BEGIN { RS="" } { gsub(/\n$/,"");         ## (newline; end of string) with (nothing)
                            gsub(/\n/," ");         ## (newline) with (space)
                            gsub(/^ *| *$/, "");    ## (pipe char) with (nothing)
                            gsub(/  +/, " ");       ## ( +) with (space)
                            gsub(/ [ ]+/, " ");     ## ([ ]+) with (space)
                            gsub(/^ +| +$/, "");    ## (pipe char) with (nothing)
                            printf $0 }' "$1"       ## prints (returns) cleaned input
}

clear
echo $(give_cpu_core_alpha_count)" "$(cpu_64_32_bit_check)" "$(get_cpu_model)" "$(get_cpu_freq)" "$(get_cpu_cache_size)" "$(get_cpu_bogomips)
echo "Drives: "$(verify_ide_drives_exist)" "$(get_libata_hdd_params)" "$(get_libata_usb_params)": Size "$(get_drive_size)"MB: "$(percent_drive_usage)"% used"
