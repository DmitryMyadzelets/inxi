#!/bin/bash
########################################################################
####  Script Name: inxi
####  version: 0.1.45
####  Date: October 29 2008
########################################################################
####  inxi is a fork of infobash, the original bash sys info script by locsmif
####  As time permits functionality and recoding will occur.
####  
####  inxi, the universal, portable, system info script for irc.
####  Tested with Irssi, Xchat, Konversation, BitchX, KSirc, ircII,
####  Gaim/Pidgin, Weechat, KVIrc and Kopete.
####  Original infobash author and copyright holder:
####  Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif <infobash@rebelhomicide.demon.nl>
####  
####  This program is free software; you can redistribute it and/or modify
####  it under the terms of the GNU General Public License as published by
####  the Free Software Foundation; either version 3 of the License, or
####  (at your option) any later version.
####  
####  This program is distributed in the hope that it will be useful,
####  but WITHOUT ANY WARRANTY; without even the implied warranty of
####  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
####  GNU General Public License for more details.
####  
####  You should have received a copy of the GNU General Public License
####  along with this program.  If not, see <http://www.gnu.org/licenses/>.

####  DEPENDENCIES
####  bash >=2.05b(bash), df;readlink;stty;tr;uname;wc(coreutils),  
####  gawk(gawk), grep(grep), hostname(hostname), lspci(pciutils),
####  ps;uptime(procps), runlevel(sysvinit), glxinfo;xdpyinfo;xrandr(xbase-clients)
####  Also the proc filesystem should be present and mounted
########################################################################
#### VARIABLES
########################################################################

## Variable initializations: null values
COLOR_SCHEME_SET=''
COLOR_SCHEME=''
DISTRO=''
DISTRO_FILE=''
A_DISTRO_GLOB=''
IRC_CLIENT=''
IRC_CLIENT_VERSION=''

## primary data array holders
A_CPU_DATA=''
A_GFX_DATA=''
A_NETWORK_DATA=''

# Variable initializations: constants
ALLUP=0         # inxi hasn't been 'booted' yet.
CRAP=0		# New parameter
CURRENT_KERNEL=$( uname -a | gawk '{print $1,$3,$(NF-1)}' )
DBI=0           # Debug Buffer Index, index into a debug buffer storing debug messages until infobash is 'all up'
DCOPOBJ="default"
DEBUG=0         # Set levels from 1-10
DEBUG_FLOOD=0   # Debug flood override: toggle on to allow long debug output
DEFAULT_SCHEME=2	# Defaults to 2, make this 1 for normal, 0 for no colorcodes at all. Set to any other valid scheme you like. Same as runtime parameter.
FLAG=0		# A throw-away 'flag' variable intended to be used throughout infobash
IBSHELL=0	# Running in a shell? Defaults to false, and is determined later.
INDENT=10	# Default indentation level
KONVI=0 # default to false, no konversation found
LSPCI=$( lspci -v | awk '{ gsub(/\(prog-if[^)]*\)/,""); print }' )
MESA=0
NO_CPU_COUNT=0	# Wether or not the string "dual" or similar is found in cpuinfo output. If so, avoid dups.
PARAMETER_LIMIT=30	# This is a variable that controls how many parameters infobash will parse in a /proc/<pid>/cmdline file before stopping.
RUNLVL=0 # just setting this to 0 to initialize and avoid test errors
SCHEME=0 # set default scheme
SHOW_HOST=1	# Set this to 0 to avoid printing the hostname 
SHOW_IRC=2	# SHOW_IRC=1 to avoid showing the irc client version number, or SHOW_IRC=0 to disable client information completely.
VERBOSITY_LEVEL=0		# Verbosity level defaults to 0, this can also be set with -v, -v2, -v3, etc as a parameter.
VERBOSITY_LEVELS=4   # Supported number of verbosity levels

# Reroute all error messages to the bitbucket (if not debugging)
if [ "$DEBUG" -eq 0 ]
then
	exec 2>/dev/null
fi 
#((DEBUG)) && exec 2>&1 # This is for debugging konversation

# Clear nullglob, because it creates unpredictable situations with IFS=$'\n' ARR=($VAR) IFS="$OIFS"
# type constructs. Stuff like [rev a1] is now seen as a glob expansion pattern, and fails, and
# therefore results in nothing. Tricky as fuck.
shopt -u nullglob
OIFS="$IFS"	# Backup the current Internal Field Seperator
FL1='-'		# These two determine separators in single line output, to force irc clients not to break off sections
FL2=''

## Script names/paths
SCRIPT_NAME="inxi"
SCRIPT_PATH=$( dirname $0 )
SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
SCRIPT_DATE=$( grep -im 1 'date:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3 " " $4 ", " $5}' )
SCRIPT_VERSION="$SCRIPT_NAME v:$SCRIPT_VERSION_NUMBER"
KONVI_CFG="konversation/scripts/$SCRIPT_NAME.conf" # relative path to $(kde-config --path data)

## Script Localization
LC_ALL="C"	# Make sure every program speaks English.
export LC_ALL 

## Output Colors
unset EMPTY	# A more elegant way to have a scheme that doesn't print color codes (neither ANSI nor mIRC) at all. See below.
#         DGREY    BLACK    RED      DRED     GREEN    DGREEN   YELLOW   DYELLOW
ANSI_COLORS="[1;30m [0;30m [1;31m [0;31m [1;32m [0;32m [1;33m [0;33m"
IRC_COLORS="   \x0314   \x0301   \x0304   \x0305   \x0309   \x0303   \x0308   \x0307"
#                 BLUE     DBLUE    MAGENTA  DMAGENTA CYAN     DCYAN    WHITE    GREY     NORMAL
ANSI_COLORS="$ANSI_COLORS [1;34m [0;34m [1;35m [0;35m [1;36m [0;36m [1;37m [0;37m [0;37m"
IRC_COLORS=" $IRC_COLORS    \x0312   \x0302   \x0313   \x0306   \x0311   \x0310   \x0300   \x0315   \x03"
#ANSI_COLORS=($ANSI_COLORS); IRC_COLORS=($IRC_COLORS)
A_COLORS_AVAILABLE=( DGREY BLACK RED DRED GREEN DGREEN YELLOW DYELLOW BLUE DBLUE MAGENTA DMAGENTA CYAN DCYAN WHITE GREY NORMAL )
# See above for notes on EMPTY
A_COLOR_SCHEMES=( EMPTY,EMPTY,EMPTY NORMAL,NORMAL,NORMAL BLUE,NORMAL,NORMAL GREEN,YELLOW,NORMAL DYELLOW,NORMAL,NORMAL CYAN,BLUE,NORMAL RED,NORMAL,NORMAL GREEN,NORMAL,NORMAL YELLOW,NORMAL,NORMAL GREEN,DGREEN,NORMAL BLUE,RED,NORMAL BLUE,NORMAL,RED YELLOW,WHITE,GREEN BLUE,NORMAL,GREEN DCYAN,NORMAL,DMAGENTA )

## Distro Data
# In cases of derived distros where the version file of the base distro can also be found under /etc, 
# the derived distro's version file should go first. (Such as with Sabayon / Gentoo)
DISTROS_DERIVED="antiX kanotix-version knoppix-version redhat-release sabayon-release sidux-version turbolinux-release zenwalk-version"
DISTROS_PRIMARY="gentoo-release mandrake-release redhat-release slackware-version SuSE-release"
# debian_version excluded from DISTROS_PRIMARY so Debian can fall through to /etc/issue detection. Same goes for Ubuntu.
DISTROS_BLIST="debian_version ubuntu_version"

## Bans Data
# Precede a banword with $'\2' to prevent it from being subject to automated escaping by the make_bans routine
# $'\1' gets weird results :
# user@host $ ARR=($'\x01'"one two" three four); echo ${ARR[0]} | hd -v
# 00000000  01 01 6f 6e 65 20 74 77  6f 0a                    |..one two.|
A_NORMAL_BANS=( corporation communications technologies technology group $'\2'"\<ltd\>" ltd. $'\2'"\<inc\>" inc. $'\2'\<co\> co. "(tm)" "(r)" $'\2'"\(rev ..\)" )
A_CPU_BANS=( cpu processor $'\2'"[0-9.]+ *[MmGg][Hh][Zz]" )

## Source global config overrides
if [ -s /etc/$SCRIPT_NAME.conf ]
then
	source /etc/$SCRIPT_NAME.conf	
fi
# Source user config overrides
if [ -s $HOME/.$SCRIPT_NAME ]
then
	source $HOME/.$SCRIPT_NAME
fi

# WARNING: In the main part below (search for 'KONVI') 
# there's a check for Konversation-specific config files.
# Any one of these can override the above if infobash is run 
# from Konversation!

########################################################################
#### UTILITY FUNCTIONS
########################################################################

#### -------------------------------------------------------------------
#### error handler and debugger
#### -------------------------------------------------------------------

# Error handling
error_handler() 
{
	case $1 in
		2)
			print_screen_output "$SCRIPT_NAME: large flood danger, debug buffer full!"
			;;
		3) 
			print_screen_output "$SCRIPT_NAME: error in colorscheme - unsupported number: $2" 
			;;
		4) 
			print_screen_output "$SCRIPT_NAME: unsupported verbosity level $2" 
			;;
		5) 
			print_screen_output "$SCRIPT_NAME: dependency not met: $2 not found in path" 
			;;
		6) 
			print_screen_output "$SCRIPT_NAME: /proc not found! Quitting..." 
			;;
		7)
			print_screen_output "$SCRIPT_NAME: unknown parameter: $2" 
			;;
		*) 
			print_screen_output "$SCRIPT_NAME: error unknown: $@" 
			set -- 99 
			;;
	esac
	exit $1
}

script_debugger() 
{
	if [ "$ALLUP" -gt 0 ]
	then
		if [ "$DEBUG" -eq 0 ]
		then
			return
		fi
		if ((DBI))
		then
			for (( DBI=0; DBI < ${#DBGBUF[@]}; DBI++ ))
			do
				print_screen_output "${DBGBUF[DBI]}"
			done
			DBI=0
		fi
		print_screen_output "$@"
	else
		if ((!DEBUG_FLOOD && DBI > 10))
		then
			error_handler 2
		fi
		DBGBUF[DBI++]="$@"
	fi
}

#### -------------------------------------------------------------------
#### print / output cleaners
#### -------------------------------------------------------------------

# inxi speaks through here. When run by Konversation, uses DCOP
# note, this is a huge bug trap, for now we're not using this at all except to
# output basic stuff. At some point in the future we'll debug the dcop stuff,
# but that only works if infobash is being run as a konversation script to begin with
print_screen_output() 
{
	if [ "$DEBUG" -gt 5 ]
	then
		if [ "$KONVI" -eq 1 ]
		then
			dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "konvi='$KONVI'  saying : '$@'"
		else
			echo "konvi='$KONVI'  saying : '$@'"
		fi
		#echo "konvi='$KONVI'  saying : '$@'"
		#((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "konvi='$KONVI'  saying : '$@'" || echo "konvi='$KONVI'  saying : '$@'"
	fi
	#((KONVI)) && dcop $DCPORT Konversation print_screen_output $DCSERVER "$DCTARGET" "$1" || echo -ne "$1\n"

	if [ "$KONVI" -eq 1 ]
	then
		dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "$1"
	else
		echo -ne "$1\n"
	fi
	#((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "$1" || echo -ne "$1\n"
	# echo -ne "$1\n"
}

## args: $1 - null or line starter; $2 - line content
create_print_line()
{
	printf "${C1}%-${INDENT}s${C2} %s" "$1" "$2"
}

# this removes newline and pipes. 
remove_erroneous_chars()
{
	## RS is input record separator
	## gsub is substitute;
	gawk 'BEGIN { RS="" } { gsub(/\n$/,"");         ## (newline; end of string) with (nothing)
									gsub(/\n/," ");         ## (newline) with (space)
									gsub(/^ *| *$/, "");    ## (pipe char) with (nothing)
									gsub(/  +/, " ");       ## ( +) with (space)
									gsub(/ [ ]+/, " ");     ## ([ ]+) with (space)
									gsub(/^ +| +$/, "");    ## (pipe char) with (nothing)
									printf $0 }' "$1"       ## prints (returns) cleaned input
}

# Enforce boilerplate and buzzword filters
sanitize_characters() 
{
	# Cannot use strong quotes to unquote a string with pipes in it! 
	# bash will interpret the |'s as usual and try to run a subshell!
	# Using weak quotes instead, or use '"..."'
	echo "$2" | gawk "BEGIN { IGNORECASE=1 } {gsub(/${!1}/,\"\");
															gsub(/ [ ]+/,\" \");    ## ([ ]+) with (space)
															gsub(/^ +| +$/,\"\");   ## (pipe char) with (nothing)
															print }"                ## prints (returns) cleaned input
}

#### -------------------------------------------------------------------
#### basic tests
#### -------------------------------------------------------------------

# Determine if any of the absolutely necessary tools are absent 
check_script_depends() 
{
	local app_name=''
	
	if [ ! -d /proc/ ]
	then
		error_handler 6
	fi

	if [ "$X" -gt 0 ]
	then
		for app_name in xrandr xdpyinfo glxinfo
		do
			type -p $app_name >/dev/null || { script_debugger "inxi: Resuming in non X mode: $app_name not found in path"; X=0; break; }
		done
	fi
	
	app_name=''
	# bc removed from deps for now
	for app_name in df free gawk grep hostname lspci ps readlink runlevel tr uname uptime wc
	do
		type -p $app_name >/dev/null || error_handler 5 "$app_name"
	done
}

# Filter boilerplate & buzzwords.
make_bans() 
{
	unset MKBANS
	# Iterate over $@
	for BANSTR
	do
		#echo "BANSTR=\"$BANSTR\"" >&2
		if [[ ${BANSTR:0:1} = $'\2' ]]
		then
			MKBANS="${MKBANS}${MKBANS+|}${BANSTR:1:${#BANSTR}-1}"
		else
			# Automatically escapes [ ] ( ) . and + 
			MKBANS="${MKBANS}${MKBANS+|}$(echo "$BANSTR" | gawk '{ gsub(/([\[\]+().])/,"\\\\&"); print }')"
		fi
	done
	echo "$MKBANS"
}

# Set the colorscheme 
# $1 = <scheme number>|<"none">
set_color_scheme() 
{
	local i='' script_colors='' color_codes=''
	
	if [[ $1 -ge ${#A_COLOR_SCHEMES[@]} ]]
	then
		set -- 1 
	fi
	SCHEME="$1" # Set a global variable to allow checking for chosen scheme later
	if [ "$IBSHELL" -gt 0 ]
	then
		color_codes=($ANSI_COLORS)
	else
		color_codes=($IRC_COLORS)
	fi
	for (( i=0; i < ${#A_COLORS_AVAILABLE[@]}; i++ ))
	do
		eval "${A_COLORS_AVAILABLE[i]}=\"${color_codes[i]}\""
	done
	IFS=","
	script_colors=(${A_COLOR_SCHEMES[$1]})
	IFS="$OIFS"
	C1="${!script_colors[0]}"
	C2="${!script_colors[1]}"
	CN="${!script_colors[2]}"
	# ((COLOR_SCHEME++)) ## note: why is this? ##
}

# Parse the null separated commandline under /proc/<pid passed in $1>/cmdline
get_cmdline() 
{
	local i=0
	
	if [ ! -e /proc/$1/cmdline ]
	then
		{ echo 0; return; }
	fi
	##print_screen_output "Marker"
	##print_screen_output "\$1='$1' -=- $(< /proc/$1/cmdline)"
	unset CMDL
	while read -d $'\0' L && [ "$i" -lt 32 ]
	do 
		CMDL[i++]="$L" ## note: make sure this is valid ##
	done </proc/$1/cmdline
	##print_screen_output "\$i='$i'"
	if [ "$i" -eq 0 ]
	then
		CMDL[0]=$(< /proc/$1/cmdline)
		if [[ -n ${CMDL[0]} ]]
		then
			i=1
		fi
	fi
	CMDLMAX=$i
}

# Get the parameters
get_parameters() 
{
	if [ -z "$1" ]
	then
		return 1
	fi
	while [ -n "$1" ]
	do
		case $1 in
		--crap)
			CRAP=1
			;;
		-d|--debug)
			DEBUG=1
			exec 2>&1
			;;
		-v|-v[0-9]|--verbose)
			if [[ ${#1} -eq 3 ]]
			then
				VERBOSITY_LEVEL="${1:2}"
			else
				if [[ $2 = --* || $2 = -* || -z $2 ]]
				then
					VERBOSITY_LEVEL=1
				else
					shift
					VERBOSITY_LEVEL="$1" 
				fi
			fi
			grep -q "^[0-${VERBOSITY_LEVELS}]$" <<< $VERBOSITY_LEVEL || error_handler 4 "$VERBOSITY_LEVEL"
			;;
		-U)
			print_screen_output "Updating $SCRIPT_NAME now..."
			wget -O $SCRIPT_PATH/$SCRIPT_NAME http://techpatterns.com/downloads/distro/$SCRIPT_NAME
			print_screen_output "To run the new version, just start $SCRIPT_NAME again."
			exit 0
			;;
		--version)
			print_version_info
			exit 0
			;;
		[0-9]|[0-9][0-9])
			# these will need to be converted to standard type options
			echo "$1" | grep -q '^[0-9][0-9]\?$' || error_handler 3 "$1"
			COLOR_SCHEME_SET='true'
			if [ -z "$COLOR_SCHEME" ]
			then
				set_color_scheme "$1"
			fi
			;;
		-h|--help)
			show_options
			exit 0
			;;
		*)
			show_options
			error_handler 7 "$1"
			;;
		esac
		shift
	done
}

show_options()
{
	print_screen_output "$SCRIPT_NAME supports the following options:"
	print_screen_output "--crap       Overrides defective or corrupted distro ID file"
	print_screen_output ""
	print_screen_output "-d --debug   Triggers script debugger output."
	print_screen_output ""
	print_screen_output "-v -v[0-${VERBOSITY_LEVELS}]   Script verbosity levels. Supported levels: 0 - ${VERBOSITY_LEVELS}"
	print_screen_output " --verbose   Examples: $SCRIPT_NAME -v | $SCRIPT_NAME -v 4 | $SCRIPT_NAME --verbose 3"
	print_screen_output ""
	print_screen_output "-U           Autoupdate script. Note: if you installed as root, you"
	print_screen_output "             must be root to update, otherwise user is fine."
	print_screen_output ""
	print_screen_output "--version    $SCRIPT_NAME information."
	print_screen_output ""
	print_screen_output "0-99         Sets color scheme to use. This will be changed soon."
	print_screen_output ""
}

print_version_info()
{
	print_screen_output "InfoBash, the universal, portable, system info script for irc."
	print_screen_output "Tested with Irssi, Xchat, Konversation, BitchX, KSirc, ircII,"
	print_screen_output "Gaim/Pidgin, Weechat, KVIrc and Kopete."
	print_screen_output "Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif <infobash@rebelhomicide.demon.nl>"
	print_screen_output " "
	print_screen_output "This program is free software; you can redistribute it and/or modify"
	print_screen_output "it under the terms of the GNU General Public License as published by"
	print_screen_output "the Free Software Foundation; either version 3 of the License, or"
	print_screen_output "(at your option) any later version."
}

########################################################################
#### MAIN FUNCTIONS
########################################################################

#### -------------------------------------------------------------------
#### initial startup stuff
#### ------------------------------------------------------------------- 

# Determine where infobash was run from
get_start_source() 
{
	local irc_client_path='' irc_client_path_lower='' non_native_konvi='' i=''
	
	if tty >/dev/null
	then
		IRC_CLIENT="Shell"
		unset IRC_CLIENT_VERSION
		IBSHELL=1
	elif [ -n "$PPID" -a -f "/proc/$PPID/exe" ]
	then
		irc_client_path=$( readlink /proc/$PPID/exe )
		# this handles the problem with konversation reporting itself as perl, which was missed because
		# when konversation starts infobash from inside itself, as a script, the parent is konversation, not perl
		if [ -z "$( grep -i 'konversation' <<< $irc_client_path )" -a -n "$( grep -i 'perl' <<< $irc_client_path )" -a -n "$( pidof konversation )" ]
		then
			irc_client_path=$( which konversation )
			non_native_konvi='true'
		fi
		irc_client_path_lower=$( tr '[:upper:]' '[:lower:]' <<< $irc_client_path )
		
		case $irc_client_path_lower in
			*irssi-text*|*irssi*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Irssi"
				;;
			*konversation*)
				# this is necessary to avoid the dcop errors from starting inxi as a /cmd started script
				if [ "$non_native_konvi" == 'true' ]
				then
					KONVI=2
				else
					KONVI=1
				fi
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk '/Konversation:/ { for (i=2;i<=NF;i++) { if (i == NF) { print $i } else { printf $i" " } } exit }' )"
				T=($IRC_CLIENT_VERSION)
				if [[ ${T[0]} == *+* ]]
				then
					# < Sho_> locsmif: The version numbers of SVN versions look like this: 
					#         "<version number of last release>+ #<build number", i.e. "1.0+ #3177" ... 
					#         for releases we remove the + and build number, i.e. "1.0" or soon "1.0.1"
					IRC_CLIENT_VERSION=" CVS $IRC_CLIENT_VERSION"
					T2="${T[0]/+/}"
				else
					IRC_CLIENT_VERSION=" ${T[0]}"
					T2="${T[0]}"
				fi
				# Remove any dots except the first, and make sure there are no trailing zeroes, 
				T2=$( echo "$T2" | gawk '{ sub(/\./, " "); gsub(/\./, ""); sub(/ /, "."); printf("%g\n", $0) }' )
				# Since Konversation 1.0, the DCOP interface has changed a bit: dcop "$DCPORT" Konversation ..etc
				# becomes : dcop "$DCPORT" default ... or dcop "$DCPORT" irc ..etc. So we check for versions smaller
				# than 1 and change the DCOP parameter/object accordingly.
				if [[ ${T2} < 1 ]]
				then
					DCOPOBJ="Konversation"
				fi
				IRC_CLIENT="Konversation"
				;; 
			*xchat-gnome)
				RC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="X-Chat-Gnome"
				;;
			*xchat*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="X-Chat"
				;;
			*bitchx*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk '
				/Version/ { a=tolower($2); gsub(/[()]|bitchx-/,"",a); print a; exit }
				$2 == "version" { a=tolower($3); sub(/bitchx-/,"",a); print a; exit }
				' )" 
				IRC_CLIENT="BitchX"
				;;
			*ircii*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $3 }' )"
				IRC_CLIENT="ircII"
				;;		
			*gaim*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Gaim"
				;;				
			*pidgin*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Pidgin"
				;;
			*weechat-curses*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v) "
				IRC_CLIENT="Weechat"
				;;
			*kvirc*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v 2>&1 | gawk '{ for (i=2;i<=NF;i++) { if (i==NF) print $i; else printf $i" " }; exit }' )"
				IRC_CLIENT="KVIrc"
				;;
			*kopete*)
				IRC_CLIENT_VERSION=" $( kopete -v | gawk '/Kopete:/ { print $2; exit }' )"
				IRC_CLIENT="Kopete"
				;;
			*perl*)
				unset IRC_CLIENT_VERSION	# KSirc is one of the possibilities now. KSirc is a wrapper around dsirc, a perl client
				get_cmdline $PPID
				for (( i=0; i <= $CMDLMAX; i++ ))
				do
					case ${CMDL[i]} in
						*dsirc*) 
							IRC_CLIENT="KSirc"
							# Dynamic runpath detection is too complex with KSirc, because KSirc is started from
							# kdeinit. /proc/<pid of the grandparent of this process>/exe is a link to /usr/bin/kdeinit
							# with one parameter which contains parameters separated by spaces(??), first param being KSirc.
							# Then, KSirc runs dsirc as the perl irc script and wraps around it. When /exec is executed,
							# dsirc is the program that runs infobash, therefore that is the parent process that we see.
							# You can imagine how hosed I am if I try to make infobash find out dynamically with which path
							# KSirc was run by browsing up the process tree in /proc. That alone is straightjacket material.
							# (KSirc sucks anyway ;)
							IRC_CLIENT_VERSION=" $( ksirc -v | gawk '/KSirc:/ { print $2; exit }' )"
							break
							;;
					esac
				done 
				if [ -z "$IRC_CLIENT_VERSION" ]
				then
					IRC_CLIENT="Unknown Perl client"
				fi
				;;
			*bash*|*sh*)
				unset IRC_CLIENT_VERSION
				IRC_CLIENT="Shell wrapper"
				;;
			*)
				IRC_CLIENT="Unknown : ${irc_client_path##*/}"
				unset IRC_CLIENT_VERSION
				;;
		esac
		if [ "$SHOW_IRC" -lt 2 ]
		then
			unset IRC_CLIENT_VERSION
		fi
	else
		IRC_CLIENT="PPID=\"$PPID\" - empty?"
		unset IRC_CLIENT_VERSION
	fi
}

set_calculated_variables()
{
	local path='' sys_path='' added_path=''
	# Extra path variable to make execute failures less likely, merged below
	local extra_paths="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin" 
	# Detect X and set variable "X" accordingly
	if [ -n "$DISPLAY" ]
	then
		X=1 
	fi
	
	# Fallback paths put into $extra_paths; This might, among others, help on gentoo.
	# Now, create a difference of $PATH and $extra_paths and add that to $PATH:
	IFS=":"
	for path in $extra_paths
	do 
		FLAG=0
		for sys_path in $PATH
		do 
			if [ "$path" == "$sys_path" ]
			then
				FLAG=1
			fi
		done
		if [ "$FLAG" -eq 0 ]
		then
			added_path="$added_path:$path"
		fi
	done
	IFS="$OIFS"
	PATH="${PATH}${added_path}"
	##echo "PATH='$PATH'" 
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""' 
	
	# Do this after sourcing of config overrides so user can customize banwords
	A_NORMAL_BANS=$( make_bans "${A_NORMAL_BANS[@]}" ) # Contrary to my previous belief, "${ARR[@]}" passes a quoted list, not one string
	A_CPU_BANS=$( make_bans "${A_CPU_BANS[@]}" )
	##echo "A_NORMAL_BANS='$A_NORMAL_BANS'"
}


#### -------------------------------------------------------------------
#### get data types
#### -------------------------------------------------------------------

get_cpu_data()
{
	local i='' j='' cpu_array_nu='' a_cpu_working='' multi_cpu=''

	IFS=$'\n'
	A_CPU_DATA=($(gawk -F': ' '
	# TAKE NOTE: \t+ will work for /proc/cpuinfo, but SOME ARBITRARY FILE used for TESTING might contain SPACES!
	# Therefore PATCH to use [ \t]+ when TESTING!
	/^processor\t+:/ { nr = $NF }
	
	/^model name/ { cpu[nr, "model"] = $NF }
	
	/^cpu MHz/    {
		if (!min) { 
			min = $NF
		} 
		else { 
			if ($NF < min) { min = $NF } 
		}
		
		if ($NF > max) { max = $NF }
		cpu[nr, "speed"] = $NF
	}
	
	/^cache size/      { cpu[nr, "cache"] = $NF }
	
	/^flags/      { cpu[nr, "flags"] = $NF }
	
	/^bogomips/   { cpu[nr, "bogomips"] = $NF }
	
	END {
		#if (!nr) { print ",,,"; exit } # <- should this be necessary or should bash handle that
		for (i = 0; i <= nr; i++) {
			print cpu[i, "model"] "," cpu[i, "speed"] "," cpu[i, "cache"] "," cpu[i, "flags"] "," cpu[i, "bogomips"]
		}
		if (!min) { 
			print "not found"
			exit 
		}
		if (min != max) { 
			printf("Min:%s%s Max:%s%s\n", min, "Mhz", max, "Mhz") 
		}
		else { 
			printf("%s %s\n", max, "Mhz") 
		}
	}
	' /proc/cpuinfo))
	
	IFS="$OIFS"
	
	for (( i=0; i < ${#A_CPU_DATA[@]} - 1; i++ ))
	do
		IFS=","
		a_cpu_working=(${A_CPU_DATA[i]})
		IFS="$OIFS"
		unset A_CPU_DATA[i]
		a_cpu_working[0]=$( sanitize_characters A_NORMAL_BANS "${a_cpu_working[0]}" )
		a_cpu_working[0]=$( sanitize_characters A_CPU_BANS "${a_cpu_working[0]}" )
		# I use all these loops so I can easily extend the cpu array created in the awk script above with more fields per cpu.
		for (( j=0; j < ${#a_cpu_working[@]}; j++ ))
		do
			if [ "$j" -gt 0 ]
			then
				A_CPU_DATA[i]="${A_CPU_DATA[i]},${a_cpu_working[j]}"
			else
				A_CPU_DATA[i]="${a_cpu_working[j]}"
			fi
		done
	done
	# test for multi core cpu present
	multi_cpu=$( grep -i 'dual\|triple\|quad' <<< "${A_CPU_DATA[@]}" )
	if [ -n "$multi_cpu" ]
	then
		NO_CPU_COUNT=1
	else
		case $(( ${#A_CPU_DATA[@]}-1 )) in 
			2)
				CPU2="Dual"
				;;
			3)
				CPU2="Triple"
				;;
			4)
				CPU2="Quad"
				;;
			[5-9]|[1-9][0-9]) 
				CPU2="${#A_CPU_DATA[@]}x"
				;;
			*) 
				unset CPU2
				;;
		esac
	fi
	
	IFS=","
	a_cpu_working=(${A_CPU_DATA[0]})
	IFS="$OIFS"
	# For the short line
	CPUMODEL="${CPU2}${CPU2+ }${a_cpu_working[0]}" # clocked at [${CPU[${#CPU[@]}-1]}]"	# old CPU2
	# set count first, this avoids an syntax highlighting error with nested {{...}}
	cpu_array_nu=$(( ${#A_CPU_DATA[@]} - 1 ))
	CPUCLOCK="${A_CPU_DATA[$cpu_array_nu]}" # old CPU3
	CPUFLAGS="${a_cpu_working[3]}" # old CPU4
	# nx = AMD stack protection extensions
	# lm = Intel 64bit extensions
	# sse, sse2, pni = sse1,2,3 gfx extensions
	# svm = AMD pacifica virtualization extensions
	# vmx = Intel IVT (vanderpool) virtualization extensions
	CPUFLAGS=$( echo "$CPUFLAGS" | awk '
	BEGIN {
			RS=" "
			ssel["sse"] = 1
			ssel["sse2"] = 2
			ssel["pni"] = 3
		sses[1] = "sse"
		sses[2] = "sse2"
		sses[3] = "sse3"
	}
	/^(nx|lm|svm|vmx)$/ {
			if (s) { s = s " " $0 }
			else { s = $0 }
	}
	/^(sse2?|pni)$/ {
			if (ssel[$0] > sse) sse = ssel[$0]
	}
	END {
			if (sse) {
						if (s) s = sses[sse] " " s;
						else s = sses[sse]
			}
			print s
	}
	' )
	
	#grep -oE '\<(nx|lm|sse[0-9]?|pni|svm|vmx)\>' | tr '\n' ' '))
	if [ -z "$CPUFLAGS" ]
	then
		CPUFLAGS="-"
	fi
}

get_distro_data()
{
	local i=''
	
	unset DISTRO
	shopt -s nullglob
	cd /etc
	A_DISTRO_GLOB=(*[-_]{release,version})
	cd "$OLDPWD"
	shopt -u nullglob
	
	if (( ${#A_DISTRO_GLOB[@]} == 1 ))
	then
		DISTRO_FILE="${A_DISTRO_GLOB}"
	elif (( ${#A_DISTRO_GLOB[@]} > 1 ))
	then
		for i in $DISTROS_DERIVED $DISTROS_PRIMARY
		do
			# Only echo works with ${var[@]}, not print_screen_output() or script_debugger()
			# This is a known bug, search for the word "strange" inside comments
			# echo "i='$i' A_DISTRO_GLOB[@]='${A_DISTRO_GLOB[@]}'"
			if [[ " ${A_DISTRO_GLOB[@]} " == *" $i "* ]]
			then
				DISTRO_FILE="${i}"
				break
			fi
		done
	fi
	if [ -n "$DISTRO_FILE" -a -s /etc/$DISTRO_FILE -a " $DISTROS_BLIST " != *" $DISTRO_FILE "* ]
	then
		DISTRO=$( remove_erroneous_chars "/etc/$DISTRO_FILE" )
	else
		# Debian pure should fall through here
		DISTRO_FILE="issue"
		DISTRO=$( gawk 'BEGIN { RS="" } { 	gsub(/\\[a-z]/,""); 
														gsub(/ [ ]+/," "); 
														gsub(/^ +| +$/,""); 
														print }' "/etc/${DISTRO_FILE}" )
	fi
	if (( ${#DISTRO} > 80 && ! CRAP ))
	then
		DISTRO="${RED}/etc/${DISTRO_FILE} corrupted, use --crap to override${NORMAL}"
	fi
	## note: figure out a more readable way to achieve whatever is intended here ##
	: ${DISTRO:=Unknown distro o_O}
}

get_graphics_data()
{
	local i=''
	
	IFS=$'\n'
	A_GFX_DATA=($( echo "$LSPCI" | gawk -F': ' '/VGA compatible controller/ { print $NF }' ))
	IFS="$OIFS"
	for (( i=0; i < ${#GFX[@]}; i++ ))
	do
		A_GFX_DATA[i]=$( sanitize_characters A_NORMAL_BANS "${A_GFX_DATA[i]}" )
	done
	
	# GFXMEM is UNUSED at the moment, because it shows AGP aperture size, which is not necessarily equal to GFX memory..
	# GFXMEM="size=[$(echo "$LSPCI" | gawk '/VGA/{while (!/^$/) {getline;if (/size=[0-9][0-9]*M/) {size2=gensub(/.*\[size=([0-9]+)M\].*/,"\\1","g",$0);if (size<size2){size=size2}}}}END{print size2}')M]"
	if [ "$X" -gt 0 ]
	then
		# Added the two ?'s , because the resolution is now reported without spaces around the 'x', as in
		# 1400x1050 instead of 1400 x 1050. Change as of X.org version 1.3.0
		RES=$( xrandr | gawk '
		/\*/ { res[++m] = gensub(/^.* ([0-9]+) ?x ?([0-9]+)[_ ].* ([0-9\.]+)\*.*$/,"\\1x\\2@\\3hz","g",$0) }
		END {
			for (n in res) {
				if (res[n] ~ /^[[:digit:]]+x[[:digit:]]+/)
					line = line ? line ", " res[n] : res[n]
			}
			if (line)
				print(line)
		}
		' )	
		
		if [ -z "$RES" ]
		then
			RES=$( xdpyinfo | gawk '/dimensions/ { print $2 }' )
		fi
		
		# X vendor and version detection.
		XVENDOR=$( xdpyinfo | gawk -F': +' '
		BEGIN { IGNORECASE=1 } 
		/vendor string/ { 
			gsub(/the|,|inc|foundation|project|coorperation/, "", $2)
			gsub(/^ +| +$/, "", $2); gsub(/  +/," ",$2)
			print $2
		} 
		' )
		
		# new method added since radeon and X.org and the disappearance of <X server name> version : ...etc 
		# Later on, the normal textual version string returned, e.g. like: X.Org version: 6.8.2
		# A failover mechanism is in place. (if $XVERNUM is empty, the release number is parsed instead)
		XVERNUM=$( xdpyinfo | awk '/version:/ { print $NF }' )
		if [ -z "$XVERNUM" ]
		then
			XVERNUM=$(xdpyinfo | gawk -F': +' '
						BEGIN { IGNORECASE=1 } 
						/vendor release number/ { 
							gsub(/0+$/,"",$2)
							gsub(/0+/,".",$2)
							print $2
						}
						')
		fi
	
		#X -version 2>&1 | gawk '/^X Window System Version/ { print $5 }'
		#This method could be used in the future to detect X when X is not running,
		#however currently infobash ignores X checks when X is not found.
		XVER="$XVENDOR $XVERNUM"
	
		IFS=$'\n'
		GLX=($(glxinfo | gawk -F ': ' '
		function join(arr, sep) {
			s=""
			i=flag=0
			for (i in arr) {
				if (flag++) s = s sep
				s = s i
			} 
			return s
		} 
	
		BEGIN { IGNORECASE=1 } 
		
		/opengl renderer/ { 
			if ($2 ~ /mesa/) {
				# Allow r300 et al, but not the rest
				if ($2 ~ / r[3-9][0-9][0-9] /) { 
					a[$2]
					f++ 
				} 
				next 
			}
			$2 && a[$2] 
		} 
		/opengl version/ && (f || $2 !~ /mesa/) { $2 && b[$2] } 
		/direct rendering/ { $2 && c[$2] } 
		
		END { 
			printf("%s\n%s\n%s\n", join(a,", "), join(b,", "), join(c,", "))
		}
		'))
		IFS="$OIFS"
		GLXR="${A_GFX_DATA[0]}"
		GLXV="${A_GFX_DATA[1]}"
		GLXDR="${A_GFX_DATA[2]}"
	
		# GLXR=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl renderer/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
		#    GLXV=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl version/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
			
		if [ -z "$GLXR" -o -z "$GLXV" ]
		then
			MESA=1
		fi
		AGPMOD=$(gawk '/agp/ && !/agpgart/ && $3 > 0 { print(gensub(/(.*)_agp.*/,"\\1","g",$1)) }' /proc/modules)
	else
		RES=$( stty -F $( readlink /proc/$PPID/fd/0 ) size | gawk '{ print $2"x"$1 }' )
		RUNLVL=$( runlevel | gawk '{ print $2 }' )
	fi
}

get_hard_drive_data()
{
	local disk='' i=''
	
	for disk in /proc/ide/ide*/hd*
	do 
		if [[ -e $disk/media && $( remove_erroneous_chars $disk/media ) = disk ]]
		then
			# BUGFIX: Ran into a debian sarge kernel that did not have the "capacity" file in the hd* directories
			if [[ ! -e $disk/capacity ]]
			then  
				CAP=0
				break
			fi
			(( CAP+=$( remove_erroneous_chars $disk/capacity ) ))
			HDDMOD="${HDDMOD}${HDDMOD+,}$( remove_erroneous_chars $disk/model )"
		fi
	done
	
	if [[ -e /proc/scsi/scsi ]]
	then
		# Silly sata detection, will also pick up usb sticks, and it is all I will put into infobash. if you want more, infoperl is on
		# the way :)
		IFS=$'\n'
		THDD=($(gawk '
		BEGIN { IGNORECASE=1 }
		/host/ {
			getline a[$0]
			getline b[$0]
		}
		END {
			for (i in a) {
				if (b[i] ~ / *type: *direct-access.*/) {
					#c=gensub(/^ *vendor: (.+) +model: (.+) +rev: (.+)$/,"\\1 \\2 \\3","g",a[i])
					c=gensub(/^ *vendor: (.+) +model: (.+) +rev:.*$/,"\\1 \\2","g",a[i])
					gsub(/ [ ]+/, " ", c); gsub(/^ +| +$/, "", c)
							#print a[i]
					if (c ~ /\<flash\>|\<pendrive\>|memory stick|memory card/) continue
					print c
				}
			}
		}
		' /proc/scsi/scsi))
		IFS="$OIFS"
	
		for (( i=0; i < ${#THDD[@]}; i++ ))
		do
			HDDMOD="${HDDMOD}${HDDMOD+,}${THDD[i]}"
		done
	fi
	
	##print_screen_output "$HDDMOD" ; exit
	if ((CAP))
	then
		HDDCAP1="$((CAP/2))"
	fi
	# See http://lanana.org/docs/device-list/devices-2.6+.txt for major numbers used below
	HDDCAP2=$( gawk '$1 ~ /^(3|22|33|8)$/ && $2 % 16 == 0 {size+=$3} END {printf("%d\n",size)}' /proc/partitions )
	
	##print_screen_output "HDDCAP1=\"$HDDCAP1\"  HDDCAP2=\"$HDDCAP2"" ; exit
	HDD=0
	for i in ${!HDDCAP*}
	do
		if [[ ${!i} -gt $HDD ]]
		then
			HDD="${!i}"
		fi
	done 
	if [ "$HDD" -gt 0 ]
	then
		HDDUSG=$( df | gawk '
		p { 
			if (/^\/dev\/(mapper\/|[hs]d[a-z][0-9]+)/) { 
				if (NF == 1) { 
					getline 
					if (NF == 5) { c += $2 } 
					else next 
				} 
				else if (NF == 6) { c += $3 } 
			} 
		} 
		/^Filesystem/ { p++ } 
		END { print c }
		' )
		HDDUSG="$((HDDUSG*100/HDD))%used"
		HDD="$(($HDD*1024/1000**3))GB"
	else
		unset HDDUSG
		HDD="unknown.."
	fi
}

get_memory_data()
{
	MEM=$( gawk '
	/^MemTotal:/ { tot = $2 }
	/^(MemFree|Buffers|Cached):/ { notused+=$2 }
	END {
		used = tot-notused
		printf("%.1f/%.1fMB\n", used/1024, tot/1024)
	}' /proc/meminfo )
}

get_networking_data()
{
	IFS=$'\n'
	A_NETWORK_DATA=( $( echo "$LSPCI" | gawk '
	BEGIN { IGNORECASE=1 }
	/^[0-9a-f:.]+ (ethernet|network) (controller|bridge)/ || /^[0-9a-f:.]+ [^:]+: .*(ethernet|network).*$/ {
		nic=gensub(/^[0-9a-f:.]+ [^:]+: (.+)$/,"\\1","g",$0)
		gsub(/realtek semiconductor/, "Realtek", nic)
		gsub(/davicom semiconductor/, "Davicom", nic)
		gsub(/,/," ", nic)
		gsub(/'"$A_NORMAL_BANS"'/, "", nic); gsub(/ [ ]+/," ", nic); gsub(/^ +| +$/,"", nic) 
		# The doublequotes above are necessary because of the pipes in the variable.
		eth[nic]++
		while (getline && !/^$/) {
			if (/I\/O/) ports[nic]=ports[nic]$4" "
		}
	}
	
	END {
		j=0
		for (i in eth) {
			if (eth[i]>1) {
				a[j]=eth[i]"x "i
				if (ports[i] != "") a[j]=a[j]", at ports: "ports[i]
			}
			else {
				a[j]=i
				if (ports[i] != "") a[j]=a[j]", at port: "ports[i];
			}
			j++
		}
		j=0
		while (a[j]) {
			print a[j]
			j++
		}
	}
	') )
	IFS="$OIFS"
}

get_processes_uptime()
{
	PROC="$(( $( ps aux | wc -l ) - 1 ))"
	UPT=$( uptime | gawk '{ a = gensub(/^.*up *([^,]*).*$/,"\\1","g",$0); gsub(/ /,"",a); print a }' )
}

#### -------------------------------------------------------------------
#### print and processing of output data
#### -------------------------------------------------------------------

print_cpu_data()
{
	local cpu_data='' i='' a_cpu_working='' cpu_number=''
	
	##print_screen_output "CPU[0]=\"${CPU[0]}\""
	IFS=","
	a_cpu_working=(${A_CPU_DATA[0]})
	IFS="$OIFS" 
	# Strange (and also some expected) behavior encountered.
	# If print_screen_output() uses $1 as the parameter to output to the screen, 
	# then passing "<text1> ${ARR[@]} <text2>"
	# will output only <text1> and the first element of ARR. That "@" splits in elements and "*" _doesn't_, 
	# is to be expected.
	# However, that text2 is consecutively truncated is somewhat strange, so take note. 
	# This has been confirmed by #bash on freenode.
	# The above mentioned only emerges when using the debugging markers below
	##print_screen_output "a_cpu_working=\"***${a_cpu_working[@]} $hostName+++++++\"----------"

	if [[ -z ${a_cpu_working[2]} ]]
	then
		a_cpu_working[2]="unknown"
	fi

	if [[ ${#A_CPU_DATA[@]} -gt 2 ]]
	then
		cpu_number="${C1}(1)${C2} "
	else
		# Array CPU always has one element: max clockfreq found. Therefore -gt and not -ge
		unset cpu_number
	fi
	cpu_data=$( create_print_line "CPU:" "${cpu_number}${a_cpu_working[0]}" )
	if [ "$VERBOSITY_LEVEL" -ge 3 ]
	then
		cpu_data="$cpu_data${C2} ${a_cpu_working[2]} cache${C2} ${C1}flags${C2} ($CPUFLAGS)${CN}"
	fi
	cpu_data="$cpu_data ${C1}clocked at${C2} ${a_cpu_working[1]} MHz${CN}"
	print_screen_output "$cpu_data"
	
	for (( i=1; i < ${#A_CPU_DATA[@]}-1; i++ ))
	do
		IFS=","
		a_cpu_working=(${A_CPU_DATA[i]})
		IFS="$OIFS"
		cpu_data=$( create_print_line " " "${C1}($(( i + 1 )))${C2} ${a_cpu_working[0]}" )
		if [ "$VERBOSITY_LEVEL" -ge 3 ]
		then
			cpu_data="$cpu_data${C2} ${a_cpu_working[2]} cache${C2} ${C1}flags${C2} ($CPUFLAGS)${CN}"
		fi
		cpu_data="$cpu_data ${C1}clocked at${C2} ${a_cpu_working[1]} MHz${CN}"
		print_screen_output "$cpu_data"
		if [ "$i" -gt 10 ]
		then
			break
		fi
	done
}

print_gfx_data()
{
	local gfx_data='' i='' card_one='Card '
	
	if [[ ${#A_GFX_DATA[@]} -gt 1 ]]
	then
		i=1
		while [[ -n ${GFX[i]} && $i -le 3 ]]
		do
			gfx_data=" ${C1}Card-$(($i+1))${C2} ${GFX[i]} "
			(( i++ ))
		done
		card_one='Card-1 '
	fi
	gfx_data=$( create_print_line "Graphics:" "${C1}$card_one${C2}${A_GFX_DATA[0]}${gfx_data}" )
	if [ "$X" -gt 0 ]
	then
		gfx_data="${gfx_data} ${C1}$XVER ${CN}[${C2} ${RES} ${CN}]"
	else
		gfx_data="${gfx_data} ${C1} tty resolution ${CN}(${C2} ${RES} ${CN})"
	fi
	print_screen_output "$gfx_data"

	if [ "$X" -gt 0 -a "$MESA" -eq 0 ]
	then
		gfx_data=$( create_print_line " " "${C1}GLX Renderer${C2} ${GLXR}${CN} | ${C1}GLX Version${C2} ${GLXV}${CN}" )
		if ((CRAP))
		then
			gfx_data="${gfx_data} ${C1}Direct rendering${C2} ${GLXDR}${CN}"
		fi
		print_screen_output "$gfx_data"
	fi
}

print_hard_disk_data()
{
	local hdd_data=''
	local root_home_data="$( df -h -T | egrep '(/|/boot|/var|/home)$'  | C1=${C1} C2=${C2} awk '{print ENVIRON["C1"]"Partition:"ENVIRON["C2"], $7, ENVIRON["C1"]"- ", ENVIRON["C1"]"size:"ENVIRON["C2"], $3, ENVIRON["C1"]"used:"ENVIRON["C2"], $4, "(", $6, ")"}' )"
	root_home_data=$( echo $root_home_data )

	if [ "$VERBOSITY_LEVEL" -ge 2 ]
	then
		hdd_data=$( create_print_line "Disks:" "${C1}HDD${C2} ${HDDMOD} ${C1}Size${C2} ${HDD} (${HDDUSG})${CN}" )
	else
		hdd_data=$( create_print_line "Disks:" "${C1}HDD Size${C2} ${HDD} (${HDDUSG})${CN}" )
	fi
	print_screen_output "$hdd_data"
	
	if [ "$VERBOSITY_LEVEL" -ge 4 ]
	then
		hdd_data=$( create_print_line " " "${root_home_data}" )
		print_screen_output "$hdd_data"
	fi
}

print_intro_data()
{
	local intro_data='' host_name=$( hostname )
	
	if [ "$SHOW_HOST" -gt 0 ]
	then
		intro_data=$( create_print_line "System:" "${C1}Host${C2} $host_name ${C1}running${C2} ${CN}" )
	else
		intro_data=$( create_print_line "System:" "${C1}running${C2} ${CN}" )
	fi
	intro_data="$intro_data ${C2}$CURRENT_KERNEL ${C1}Distro${C2} $DISTRO ${CN}"
	print_screen_output "$intro_data"
}

print_networking_data()
{
	local i='' card_plural='s' card_one='Card-1 ' network_data=''

	if [[ -n ${A_NETWORK_DATA[@]} ]]
	then
		if [[ ${#A_NETWORK_DATA[@]} -le 1 ]]
		then
			card_plural=''
			card_one=''
		fi
		i=0
		network_data=$( create_print_line "Network:" "${C1}$card_one${C2}${A_NETWORK_DATA[i]}" )
		print_screen_output "$network_data"
		while [[ -n ${A_NETWORK_DATA[++i]} ]]
		do
			network_data=$( create_print_line " " "${C1}Card-$(($i+1))${C2} ${A_NETWORK_DATA[i]}" )
			print_screen_output "$network_data"
		done
	fi
}

print_short_data()
{
	local short_data='' i=''
	
	#set_color_scheme 12
	if [ "$IBSHELL" -eq 0 ]
	then
		for i in $C1 $C2 $CN
		do
			case "$i" in 
				"$GREEN"|"$WHITE"|"$YELLOW"|"$CYAN") BGBLACK=1
				;;
			esac
		done
		if [ "$BGBLACK" -gt 0 ]
		then
			for i in C1 C2 CN
			do
				if [[ "${!i}" = "$NORMAL" ]]
				then
					declare $i="${!i}15,1"
				else
					declare $i="${!i},1"
				fi
			done
			#C1="${C1},1"; C2="${C2},1"; CN="${CN},1"
		fi
	fi
	short_data=$( echo -ne "${C1}CPU${CN}[${C2}${CPUMODEL} clocked at ${CPUCLOCK}${CN}]  ${C1}Kernel${CN}[${C2}${CURRENT_KERNEL}${CN}] ${C1}Up${CN}[${C2}${FL2}${FL1}${UPT}${FL1}${CN}]  ${C1}Mem${CN}[${C2}${FL2}${FL1}${MEM}${FL1}${CN}]  ${C1}HDD${CN}[${C2}${FL2}${FL1}${HDD}($HDDUSG)${FL1}${CN}]  ${C1}Procs${CN}[${C2}${FL2}${FL1}${PROC}${FL1}${CN}]" )

	if [ "$SHOW_IRC" -gt 0 ]
	then
		short_data="${short_data}$( echo -ne "  ${C1}Client${CN}[${C2}${IRC_CLIENT}${IRC_CLIENT_VERSION}${CN}]" )"
	fi
	short_data="${short_data} | ${C1}${SCRIPT_VERSION}${CN}"
	if [ "$SCHEME" -gt 0 ]
	then
		short_data="${short_data}$( echo -ne "$NORMAL" )"
	fi
	print_screen_output "$short_data"
}

print_system_data()
{
	local system_data='' 
	
	# Some code could look superfluous but BitchX doesn't like lines not ending in a newline. F*&k that bitch!
	# long_last=$( echo -ne "${C1}Processes${C2} ${PROC}${CN} | ${C1}Uptime${C2} ${UPT}${CN} | ${C1}Memory${C2} ${MEM}${CN}" )
	system_data=$( printf "${C1}%-${INDENT}s${C2} %s" "Info:" "${C1}Processes${C2} ${PROC}${CN} | ${C1}Uptime${C2} ${UPT}${CN} | ${C1}Memory${C2} ${MEM}${CN}" )
	
	if [ "$RUNLVL" -gt 0 ]
	then
		system_data="${system_data}$( echo -ne " | ${C1}Runlevel${C2} ${RUNLVL}${CN}" )"
	fi
	
	if [ "$SHOW_IRC" -gt 0 ]
	then
		system_data="${system_data}$( echo -ne " | ${C1}Client${C2} ${IRC_CLIENT}${IRC_CLIENT_VERSION}${CN}" )"
	fi
	system_data="${system_data}$( echo -ne " | ${C1}${SCRIPT_VERSION}" )"
	
	if [ "$SCHEME" -gt 0 ]
	then
		system_data="${system_data}$( echo -ne "${NORMAL}" )"
	fi
	print_screen_output "$system_data"
}

print_it_out()
{
	case "$VERBOSITY_LEVEL" in
		0)
			print_short_data
			;;
		*)
			print_intro_data
			print_cpu_data
			print_gfx_data
	
			if [ "$VERBOSITY_LEVEL" -ge 2 ]
			then
				print_networking_data
			fi
			
			print_hard_disk_data
			print_system_data
			;;
	esac
}

########################################################################
#### SCRIPT EXECUTION
########################################################################
set_calculated_variables
# Check for dependencies before running any commands in this script! So yes, here!!
check_script_depends

get_start_source

# note: this only works if it's run from inside konversation as a script builtin or something
# only do this if inxi has been started as a konversation script, otherwise bypass this
if [ "$KONVI" -eq 1 ]
then
	DCPORT="$1"
	DCSERVER="$2"
	DCTARGET="$3"
	shift 3
	# The section below is on request of Argonel from the Konversation developer team:
	# it sources config files like $HOME/.kde/share/apps/konversation/scripts/inxi.conf
	IFS=":"
	for kde_config in $( kde-config --path data )
	do
		if [[ -r ${kde_config}${KONVI_CFG} ]]
		then 
			source "${kde_config}${KONVI_CFG}"
			break
		fi
	done
	IFS="$OIFS"
fi
# 	print_screen_output "DCPORT: $DCPORT"
# 	print_screen_output "DCSERVER: $DCSERVER"
# 	print_screen_output "DCTARGET: $DCTARGET"

# "$@" passes every parameter separately quoted, "$*" passes all parameters as one quoted parameter.
get_parameters "$@"

# If no colorscheme was set in the parameter handling routine, then set the default scheme
if [ "$COLOR_SCHEME_SET" != 'true' ]
then
	set_color_scheme "$DEFAULT_SCHEME"
fi

ALLUP=1
script_debugger "ALLUP=1 : inxi up and running.."

# assemble data for output
get_distro_data
get_cpu_data
get_hard_drive_data
get_memory_data
get_networking_data
get_processes_uptime
get_graphics_data

# then create the output
print_it_out

## last steps
if [ "$IBSHELL" -gt 0 -a "$SCHEME" -gt 0 ]
then
	echo -n "[0m"
fi

exit 0  # weechat's executor plugin forced me to do this, and rightfully so, because else the exit code from the last command is taken..
